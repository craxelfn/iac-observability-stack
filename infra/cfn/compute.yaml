AWSTemplateFormatVersion: '2010-09-09'
Description: |
  MasterProject Compute Infrastructure
  Creates ALB, Target Group, IAM Role, Launch Template, and Auto Scaling Group
  with full observability agents (CloudWatch, X-Ray, CodeDeploy).

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
    Description: Environment name for resource tagging

  Project:
    Type: String
    Default: MasterProject
    Description: Project name for resource tagging

  NetworkStackName:
    Type: String
    Default: mp-network
    Description: Name of the network stack for cross-stack references

  SecurityStackName:
    Type: String
    Default: mp-security
    Description: Name of the security stack for cross-stack references

  InstanceType:
    Type: String
    Default: t3.small
    AllowedValues:
      - t3.micro
      - t3.small
      - t3.medium
    Description: EC2 instance type

  MinSize:
    Type: Number
    Default: 2
    Description: Minimum number of instances in ASG

  MaxSize:
    Type: Number
    Default: 6
    Description: Maximum number of instances in ASG

  DesiredCapacity:
    Type: Number
    Default: 2
    Description: Desired number of instances in ASG

  LatestAmiId:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64'
    Description: Latest Amazon Linux 2023 AMI ID from SSM Parameter Store

Resources:
  # ============================================================================
  # Application Load Balancer
  # ============================================================================
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${Project}-${Environment}-alb'
      Scheme: internet-facing
      Type: application
      Subnets:
        - !ImportValue
          Fn::Sub: '${NetworkStackName}-PublicSubnet1Id'
        - !ImportValue
          Fn::Sub: '${NetworkStackName}-PublicSubnet2Id'
      SecurityGroups:
        - !ImportValue
          Fn::Sub: '${SecurityStackName}-ALBSecurityGroupId'
      Tags:
        - Key: Name
          Value: !Sub '${Project}-${Environment}-alb'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref Project

  # ============================================================================
  # Target Group
  # ============================================================================
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${Project}-${Environment}-tg'
      Port: 8080
      Protocol: HTTP
      VpcId: !ImportValue
        Fn::Sub: '${NetworkStackName}-VpcId'
      TargetType: instance
      HealthCheckEnabled: true
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3
      Matcher:
        HttpCode: '200'
      Tags:
        - Key: Name
          Value: !Sub '${Project}-${Environment}-tg'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref Project

  # ============================================================================
  # ALB Listener
  # ============================================================================
  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup

  # ============================================================================
  # IAM Role for EC2
  # ============================================================================
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${Project}-${Environment}-ec2-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess
      Policies:
        - PolicyName: !Sub '${Project}-${Environment}-ec2-policy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # CloudWatch Logs
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/masterproject/*'
              # CloudWatch Metrics
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: '*'
                Condition:
                  StringEquals:
                    cloudwatch:namespace: MasterProject
              # X-Ray (additional permissions beyond managed policy)
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                  - xray:GetSamplingStatisticSummaries
                Resource: '*'
              # S3 read access for CodeDeploy artifacts
              - Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                Resource:
                  - !Sub 'arn:aws:s3:::aws-codedeploy-${AWS::Region}/*'
                  - !Sub 'arn:aws:s3:::${Project}-${Environment}-artifacts/*'
              # CodeDeploy agent permissions
              - Effect: Allow
                Action:
                  - codedeploy:*
                Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub '${Project}-${Environment}-ec2-role'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref Project

  # ============================================================================
  # Instance Profile
  # ============================================================================
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub '${Project}-${Environment}-ec2-profile'
      Roles:
        - !Ref EC2Role

  # ============================================================================
  # Launch Template
  # ============================================================================
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${Project}-${Environment}-lt'
      LaunchTemplateData:
        ImageId: !Ref LatestAmiId
        InstanceType: !Ref InstanceType
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        SecurityGroupIds:
          - !ImportValue
            Fn::Sub: '${SecurityStackName}-EC2SecurityGroupId'
        BlockDeviceMappings:
          - DeviceName: /dev/xvda
            Ebs:
              VolumeSize: 20
              VolumeType: gp3
              Encrypted: true
              DeleteOnTermination: true
        MetadataOptions:
          HttpEndpoint: enabled
          HttpTokens: required
          HttpPutResponseHopLimit: 2
        Monitoring:
          Enabled: true
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            set -ex
            
            # Update system
            dnf update -y
            
            # Install Python 3.11 (do NOT change system python3 - dnf depends on python3.9)
            dnf install -y python3.11 python3.11-pip
            
            # Install CodeDeploy agent
            dnf install -y ruby wget
            cd /tmp
            wget https://aws-codedeploy-${AWS::Region}.s3.${AWS::Region}.amazonaws.com/latest/install
            chmod +x ./install
            ./install auto
            systemctl enable codedeploy-agent
            systemctl start codedeploy-agent
            
            # Install CloudWatch Agent
            dnf install -y amazon-cloudwatch-agent
            
            # Configure CloudWatch Agent
            cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOF'
            {
              "agent": {
                "metrics_collection_interval": 60,
                "run_as_user": "root"
              },
              "logs": {
                "logs_collected": {
                  "files": {
                    "collect_list": [
                      {
                        "file_path": "/var/log/masterproject/app.log",
                        "log_group_name": "/masterproject/app",
                        "log_stream_name": "{instance_id}",
                        "timezone": "UTC"
                      },
                      {
                        "file_path": "/var/log/messages",
                        "log_group_name": "/masterproject/system",
                        "log_stream_name": "{instance_id}-messages",
                        "timezone": "UTC"
                      }
                    ]
                  }
                }
              },
              "metrics": {
                "namespace": "MasterProject",
                "metrics_collected": {
                  "cpu": {
                    "measurement": ["cpu_usage_idle", "cpu_usage_user", "cpu_usage_system"],
                    "metrics_collection_interval": 60
                  },
                  "mem": {
                    "measurement": ["mem_used_percent"],
                    "metrics_collection_interval": 60
                  },
                  "disk": {
                    "measurement": ["disk_used_percent"],
                    "metrics_collection_interval": 60,
                    "resources": ["/"]
                  }
                },
                "append_dimensions": {
                  "InstanceId": "${!aws:InstanceId}",
                  "AutoScalingGroupName": "${!aws:AutoScalingGroupName}"
                }
              }
            }
            EOF
            
            # Start CloudWatch Agent
            /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
              -a fetch-config \
              -m ec2 \
              -s \
              -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json
            
            # Install X-Ray Daemon
            curl -o /tmp/xray-daemon.rpm \
              https://s3.us-east-2.amazonaws.com/aws-xray-assets.us-east-2/xray-daemon/aws-xray-daemon-3.x.rpm
            dnf install -y /tmp/xray-daemon.rpm
            
            # Configure X-Ray Daemon
            cat > /etc/amazon/xray/cfg.yaml << 'EOF'
            Socket:
              UDPAddress: "127.0.0.1:2000"
              TCPAddress: "127.0.0.1:2000"
            Logging:
              LogLevel: "info"
              LogPath: "/var/log/xray/xray.log"
            LocalMode: false
            ResourceARN: ""
            RoleARN: ""
            NoVerifySSL: false
            ProxyAddress: ""
            Region: "${AWS::Region}"
            Version: 2
            EOF
            
            # Start X-Ray Daemon
            systemctl enable xray
            systemctl start xray
            
            # Install CodeDeploy Agent
            dnf install -y ruby wget
            cd /tmp
            wget https://aws-codedeploy-${AWS::Region}.s3.${AWS::Region}.amazonaws.com/latest/install
            chmod +x ./install
            ./install auto
            systemctl enable codedeploy-agent
            systemctl start codedeploy-agent
            
            # Create application directory
            mkdir -p /opt/masterproject
            mkdir -p /var/log/masterproject
            chown -R ec2-user:ec2-user /opt/masterproject
            chown -R ec2-user:ec2-user /var/log/masterproject
            
            # Create requirements.txt
            cat > /opt/masterproject/requirements.txt << 'REQEOF'
            # MasterProject API Dependencies
            fastapi==0.109.0
            uvicorn[standard]==0.27.0
            aws-xray-sdk==2.12.1
            httpx==0.26.0
            requests==2.31.0
            pydantic==2.5.3
            pydantic-settings==2.1.0
            python-dotenv==1.0.0
            REQEOF
            
            # Create config.py
            cat > /opt/masterproject/config.py << 'CONFIGEOF'
            import os
            from dataclasses import dataclass
            
            @dataclass
            class Settings:
                SERVICE_NAME: str = os.getenv("SERVICE_NAME", "masterproject-api")
                ENVIRONMENT: str = os.getenv("ENVIRONMENT", "dev")
                DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"
                HOST: str = os.getenv("HOST", "0.0.0.0")
                PORT: int = int(os.getenv("PORT", "8080"))
                AWS_REGION: str = os.getenv("AWS_REGION", "us-east-2")
                XRAY_DAEMON_ADDRESS: str = os.getenv("XRAY_DAEMON_ADDRESS", "127.0.0.1:2000")
                XRAY_TRACING_ENABLED: bool = os.getenv("XRAY_TRACING_ENABLED", "true").lower() == "true"
                LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO")
                LOG_FORMAT: str = os.getenv("LOG_FORMAT", "json")
            
            settings = Settings()
            CONFIGEOF
            
            # Create main.py
            cat > /opt/masterproject/main.py << 'MAINEOF'
            import json
            import logging
            import random
            import time
            import uuid
            from contextlib import asynccontextmanager
            from datetime import datetime, timezone
            from typing import Optional
            
            from fastapi import FastAPI, Query, Request, Response
            from fastapi.responses import JSONResponse
            
            from config import settings
            
            try:
                from aws_xray_sdk.core import xray_recorder, patch_all
                from aws_xray_sdk.ext.fastapi.middleware import XRayMiddleware
                XRAY_ENABLED = True
                patch_all()
            except ImportError:
                XRAY_ENABLED = False
                xray_recorder = None
            
            class JSONFormatter(logging.Formatter):
                def format(self, record: logging.LogRecord) -> str:
                    log_entry = {
                        "timestamp": datetime.now(timezone.utc).isoformat(),
                        "level": record.levelname,
                        "message": record.getMessage(),
                        "logger": record.name,
                    }
                    if hasattr(record, "request_id"):
                        log_entry["request_id"] = record.request_id
                    if hasattr(record, "path"):
                        log_entry["path"] = record.path
                    if hasattr(record, "method"):
                        log_entry["method"] = record.method
                    if hasattr(record, "duration_ms"):
                        log_entry["duration_ms"] = record.duration_ms
                    if hasattr(record, "status_code"):
                        log_entry["status_code"] = record.status_code
                    if hasattr(record, "client_ip"):
                        log_entry["client_ip"] = record.client_ip
                    if record.exc_info:
                        log_entry["exception"] = self.formatException(record.exc_info)
                    return json.dumps(log_entry)
            
            def setup_logging():
                logger = logging.getLogger("masterproject")
                logger.setLevel(logging.INFO)
                logger.handlers.clear()
                handler = logging.StreamHandler()
                handler.setFormatter(JSONFormatter())
                logger.addHandler(handler)
                # Also log to file
                file_handler = logging.FileHandler("/var/log/masterproject/app.log")
                file_handler.setFormatter(JSONFormatter())
                logger.addHandler(file_handler)
                return logger
            
            logger = setup_logging()
            
            @asynccontextmanager
            async def lifespan(app: FastAPI):
                logger.info("Application starting up", extra={"event": "startup"})
                yield
                logger.info("Application shutting down", extra={"event": "shutdown"})
            
            app = FastAPI(
                title="MasterProject API",
                description="Simple REST API with comprehensive observability",
                version="1.0.0",
                lifespan=lifespan,
            )
            
            if XRAY_ENABLED:
                xray_recorder.configure(
                    service=settings.SERVICE_NAME,
                    sampling=True,
                    context_missing='LOG_ERROR',
                    daemon_address=settings.XRAY_DAEMON_ADDRESS,
                )
                app.add_middleware(XRayMiddleware, recorder=xray_recorder)
                logger.info("X-Ray tracing enabled")
            else:
                logger.warning("X-Ray SDK not available, tracing disabled")
            
            @app.middleware("http")
            async def logging_middleware(request: Request, call_next):
                request_id = str(uuid.uuid4())
                start_time = time.perf_counter()
                request.state.request_id = request_id
                try:
                    response = await call_next(request)
                except Exception as e:
                    duration_ms = (time.perf_counter() - start_time) * 1000
                    logger.error(
                        f"Request failed: {str(e)}",
                        extra={
                            "request_id": request_id,
                            "path": request.url.path,
                            "method": request.method,
                            "duration_ms": round(duration_ms, 2),
                            "client_ip": request.client.host if request.client else None,
                        },
                        exc_info=True,
                    )
                    raise
                duration_ms = (time.perf_counter() - start_time) * 1000
                logger.info(
                    f"{request.method} {request.url.path} - {response.status_code}",
                    extra={
                        "request_id": request_id,
                        "path": request.url.path,
                        "method": request.method,
                        "status_code": response.status_code,
                        "duration_ms": round(duration_ms, 2),
                        "client_ip": request.client.host if request.client else None,
                    },
                )
                response.headers["X-Request-ID"] = request_id
                return response
            
            @app.get("/health")
            async def health_check():
                return {
                    "status": "healthy",
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                    "service": settings.SERVICE_NAME,
                    "version": "1.0.0",
                }
            
            @app.get("/items")
            async def get_items(
                request: Request,
                count: int = Query(default=10, ge=1, le=100, description="Number of items to return"),
            ):
                if XRAY_ENABLED and xray_recorder:
                    subsegment = xray_recorder.begin_subsegment("business_logic")
                try:
                    latency_ms = random.randint(50, 200)
                    time.sleep(latency_ms / 1000)
                    items = []
                    for i in range(count):
                        items.append({
                            "id": str(uuid.uuid4()),
                            "name": f"Item {i + 1}",
                            "description": f"This is a sample item number {i + 1}",
                            "price": round(random.uniform(10.0, 100.0), 2),
                            "category": random.choice(["electronics", "clothing", "books", "food"]),
                            "in_stock": random.choice([True, False]),
                            "created_at": datetime.now(timezone.utc).isoformat(),
                        })
                    if XRAY_ENABLED and xray_recorder and subsegment:
                        subsegment.put_annotation("item_count", count)
                        subsegment.put_metadata("simulated_latency_ms", latency_ms)
                finally:
                    if XRAY_ENABLED and xray_recorder:
                        xray_recorder.end_subsegment()
                return {
                    "items": items,
                    "count": len(items),
                    "request_id": getattr(request.state, "request_id", None),
                }
            
            @app.get("/error")
            async def trigger_error(request: Request):
                request_id = getattr(request.state, "request_id", "unknown")
                logger.error(
                    "Intentional error triggered for testing",
                    extra={
                        "request_id": request_id,
                        "path": "/error",
                        "method": "GET",
                    },
                )
                return JSONResponse(
                    status_code=500,
                    content={
                        "error": "Intentional error for testing purposes",
                        "message": "This endpoint intentionally returns a 500 error",
                        "request_id": request_id,
                        "timestamp": datetime.now(timezone.utc).isoformat(),
                    },
                )
            
            @app.get("/")
            async def root():
                return {
                    "service": settings.SERVICE_NAME,
                    "version": "1.0.0",
                    "endpoints": {
                        "health": "/health",
                        "items": "/items?count=10",
                        "error": "/error",
                    },
                    "documentation": "/docs",
                }
            
            @app.exception_handler(Exception)
            async def global_exception_handler(request: Request, exc: Exception):
                request_id = getattr(request.state, "request_id", "unknown")
                logger.error(
                    f"Unhandled exception: {str(exc)}",
                    extra={
                        "request_id": request_id,
                        "path": request.url.path,
                        "method": request.method,
                    },
                    exc_info=True,
                )
                return JSONResponse(
                    status_code=500,
                    content={
                        "error": "Internal server error",
                        "request_id": request_id,
                        "timestamp": datetime.now(timezone.utc).isoformat(),
                    },
                )
            
            if __name__ == "__main__":
                import uvicorn
                uvicorn.run(
                    "main:app",
                    host=settings.HOST,
                    port=settings.PORT,
                    reload=settings.DEBUG,
                    log_level="info",
                )
            MAINEOF
            
            # Set ownership
            chown -R ec2-user:ec2-user /opt/masterproject
            
            # Install Python dependencies using python3.11 explicitly
            python3.11 -m pip install -r /opt/masterproject/requirements.txt
            
            # Create systemd service for the application
            cat > /etc/systemd/system/masterproject.service << 'SERVICEEOF'
            [Unit]
            Description=MasterProject API
            After=network.target
            
            [Service]
            Type=simple
            User=ec2-user
            WorkingDirectory=/opt/masterproject
            Environment=ENVIRONMENT=dev
            Environment=AWS_REGION=us-east-2
            ExecStart=/usr/bin/python3.11 -m uvicorn main:app --host 0.0.0.0 --port 8080
            Restart=always
            RestartSec=5
            StandardOutput=append:/var/log/masterproject/app.log
            StandardError=append:/var/log/masterproject/app.log
            
            [Install]
            WantedBy=multi-user.target
            SERVICEEOF
            
            # Enable and start the application service
            systemctl daemon-reload
            systemctl enable masterproject
            
            # Create log file with correct ownership before starting service
            touch /var/log/masterproject/app.log
            chown -R ec2-user:ec2-user /var/log/masterproject
            
            systemctl start masterproject
            
            # Signal completion (for ASG health checks)
            echo "UserData script completed successfully" >> /var/log/masterproject/bootstrap.log
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${Project}-${Environment}-instance'
              - Key: Environment
                Value: !Ref Environment
              - Key: Project
                Value: !Ref Project

  # ============================================================================
  # Auto Scaling Group
  # ============================================================================
  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub '${Project}-${Environment}-asg'
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      MinSize: !Ref MinSize
      MaxSize: !Ref MaxSize
      DesiredCapacity: !Ref DesiredCapacity
      VPCZoneIdentifier:
        - !ImportValue
          Fn::Sub: '${NetworkStackName}-PrivateSubnet1Id'
        - !ImportValue
          Fn::Sub: '${NetworkStackName}-PrivateSubnet2Id'
      TargetGroupARNs:
        - !Ref TargetGroup
      HealthCheckType: ELB
      HealthCheckGracePeriod: 300
      MetricsCollection:
        - Granularity: 1Minute
          Metrics:
            - GroupMinSize
            - GroupMaxSize
            - GroupDesiredCapacity
            - GroupInServiceInstances
            - GroupTotalInstances
      Tags:
        - Key: Name
          Value: !Sub '${Project}-${Environment}-asg-instance'
          PropagateAtLaunch: true
        - Key: Environment
          Value: !Ref Environment
          PropagateAtLaunch: true
        - Key: Project
          Value: !Ref Project
          PropagateAtLaunch: true

# ============================================================================
# Outputs
# ============================================================================
Outputs:
  ALBDnsName:
    Description: DNS name of the Application Load Balancer
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub '${AWS::StackName}-ALBDnsName'

  ALBArn:
    Description: ARN of the Application Load Balancer
    Value: !Ref ApplicationLoadBalancer
    Export:
      Name: !Sub '${AWS::StackName}-ALBArn'

  ALBFullName:
    Description: Full name of the ALB for CloudWatch metrics
    Value: !GetAtt ApplicationLoadBalancer.LoadBalancerFullName
    Export:
      Name: !Sub '${AWS::StackName}-ALBFullName'

  TargetGroupArn:
    Description: ARN of the Target Group
    Value: !Ref TargetGroup
    Export:
      Name: !Sub '${AWS::StackName}-TargetGroupArn'

  TargetGroupFullName:
    Description: Full name of the Target Group for CloudWatch metrics
    Value: !GetAtt TargetGroup.TargetGroupFullName
    Export:
      Name: !Sub '${AWS::StackName}-TargetGroupFullName'

  AutoScalingGroupName:
    Description: Name of the Auto Scaling Group
    Value: !Ref AutoScalingGroup
    Export:
      Name: !Sub '${AWS::StackName}-AutoScalingGroupName'

  ASGName:
    Description: ASG Name for CodeDeploy
    Value: !Sub '${Project}-${Environment}-asg'
    Export:
      Name: !Sub '${AWS::StackName}-ASGName'

  TargetGroupName:
    Description: Target Group Name for CodeDeploy
    Value: !Sub '${Project}-${Environment}-tg'
    Export:
      Name: !Sub '${AWS::StackName}-TargetGroupName'

  EC2RoleArn:
    Description: ARN of the EC2 IAM Role
    Value: !GetAtt EC2Role.Arn
    Export:
      Name: !Sub '${AWS::StackName}-EC2RoleArn'

  LaunchTemplateId:
    Description: ID of the Launch Template
    Value: !Ref LaunchTemplate
    Export:
      Name: !Sub '${AWS::StackName}-LaunchTemplateId'

  StackName:
    Description: Stack name for cross-stack references
    Value: !Ref AWS::StackName
    Export:
      Name: !Sub '${AWS::StackName}-StackName'
